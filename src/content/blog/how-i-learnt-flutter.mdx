---
title: "How I Learnt Flutter"
date: "2025-05-25"
description: "A fun story of how I learnt Flutter by building a real project and how you can learn it too (without burning out)."
category: "Development"
tags: ["Flutter", "Dart", "Mobile Development", "Clean Architecture"]
---

I started learning **Flutter** at the very beginning of 2024, and it all began because of a real need — I wanted to build an app for my university, the **VITAP Student App**. I didn’t know a thing about Flutter at that point, but the idea of building something functional and useful for students around me was too exciting to ignore. So I jumped in, headfirst.

Now, I didn’t start the "textbook way". Nope. I went the chaotic route — straight-up **ChatGPT-driven development**. I would ask it how to do stuff, then sit and debug errors for hours. Honestly, 80% of the time it wouldn’t work on the first try, but I learned a lot by just messing around. I barely watched any tutorials or read documentation at this point (yeah, I was lazy). But soon, things started to fall apart — the codebase became a mess, and I had no clue how to scale or structure it properly.

That’s when I stumbled upon [@RivaanRanawat]((https://www.youtube.com/@RivaanRanawat)) on YouTube. And wow — that guy literally saved my project and my sanity. His channel is a goldmine. Clean architecture? Check. MVVM pattern? Check. BLoC? Riverpod? Testing? Everything is there, all well-explained and for free. I owe a big chunk of my learning to him, and if you're just starting out with Flutter — **this is the one channel I’d recommend**.

At one point, I realized that randomly hacking things together wasn't going to cut it if I wanted to build real apps. So I sat down and followed a structured path (finally). I started with **Dart**, since you kinda need that before writing Flutter apps. If you already know an OOP language like Java, Dart will feel familiar — just a few extra things to learn like `final vs const`, mixins, enums, nullable types, and exception handling.

Once I got the hang of Dart, I dived into Flutter basics — layout, widgets, navigation, and theming. I followed a clean, beginner-friendly Flutter playlist and slowly began to understand how Flutter's reactive UI system worked. After that, I explored **Futures** and `async/await`, because asynchronous code is everywhere in Flutter.

Then came the holy war: **State Management**. People usually take one of two paths — **BLoC** or **Riverpod**. I tried both. BLoC felt more structured and formal, especially for larger apps — it forces you to separate UI from business logic neatly. Riverpod, on the other hand, felt more modern, flexible, and easier to start with. If you're someone who doesn’t want to write 5 files for a button click, you might like Riverpod. But if you're into predictable, testable patterns, give BLoC a try. I’d say — explore both and see what feels right for your project.

After learning state management, I got into **architectural patterns** like **MVVM** and **Clean Architecture**, and trust me, that’s when my apps started to feel truly “production ready”. It’s like suddenly your code starts making sense and isn’t just a pile of spaghetti. Finally, I dove into **testing in Flutter** — unit testing, widget testing, integration testing — and it was really helpful to gain confidence in my code before releasing updates.

Looking back, my journey with Flutter wasn’t the cleanest — but it was fun and filled with late-night debugging and random “aha!” moments. If you're someone who learns by doing (and breaking things), Flutter is a great playground. You can build real stuff early on, and grow your skills along the way.

So yeah — if you're planning to learn Flutter, don’t stress too much. Start with the basics, build a simple app, and keep improving. Lean on creators like **Rivaan**, and most importantly — enjoy the process. Debugging might suck sometimes, but seeing your app live and working? Totally worth it.